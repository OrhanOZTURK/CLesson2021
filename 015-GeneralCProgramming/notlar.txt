
#include "utility.h"
#include <stdio.h>

int main()
{
    int x, y;
    printf("iki tam sayi girin : ");
    scanf("%d%d", &x, &y);

    for (int i = x; i < y; ++i) {
        if(isprime(i)){
            printf("%d ",i);
            sleep(0.08);
        }
    }

    dashline();

    return 0;
}

/****************************************************/
/****************************************************/


switch kontrol deyimi
goto kontrol deyimi


switch kontrol deyimi
programın akışını expression ifadesine göre farklı noktalara yönlendirir

integer expression ---> gercerk sayı ve pointer ifade olamaz

case label

switch(integer expression)
{
case integer_constant_exp1:
   statement1;
   statement2;
   statement3;
case integer_constant_exp2:
   statement1;
   statement2;
case integer_constant_exp3:
   statement1;
   statement2;
   statement3;

}


#include "utility.h"
#include <stdio.h>

int main()
{
    int n;
    printf("haftanin kacinci gunu : ");
    scanf("%d", &n);

    switch (n) {
        case 1: printf("pazartesi\n");
        case 2: printf("sali\n");
        case 3: printf("carsamba\n");
        case 4: printf("persembe\n");
        case 5: printf("cuma\n");
        case 6: printf("cumartesi\n");
        case 7: printf("pazar\n");
    }

    printf("switch deyimi yurutuldu\n");

    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <stdio.h>

int main()
{
    int n;
    printf("haftanin kacinci gunu : ");
    scanf("%d", &n);

    switch (n) {
        case 1: printf("pazartesi\n");break;
        case 2: printf("sali\n");break;
        case 3: printf("carsamba\n");break;
        case 4: printf("persembe\n");break;
        case 5: printf("cuma\n");break;
        case 6: printf("cumartesi\n");break;
        case 7: printf("pazar\n");break;
    }

    printf("switch deyimi yurutuldu\n");

    return 0;
}

/****************************************************/
/****************************************************/

case label 'larında ne kullanabilirim


tam sayı türlerinden sabit ifadeleri olmak zorunda

case 'A'    bu gecerli

case 3


#define    BLUE   1
#define    BLACK  2

switch(n){
 case BLUE:
 case BLACK:
}

//bunu kullanmayın
switch(n){
 case 5*2-6+7:
}

----------

C dilinde her labeldan sonra bir deyim olmak zorunda


#include "utility.h"
#include <stdio.h>

int main()
{
    int n;
    printf("haftanin kacinci gunu : ");
    scanf("%d", &n);

    switch (n) {
    case 1:
    case 2:
    case 3: printf("carsamba\n");
    case 4:

    }




    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <stdio.h>

int main()
{
    int n;
    printf("haftanin kacinci gunu : ");
    scanf("%d", &n);

    //içi boş switch gecerli
    switch (n) {

    }




    return 0;
}

/****************************************************/
/****************************************************/



#include "utility.h"
#include <stdio.h>

int main()
{
    int n;
    printf("haftanin kacinci gunu : ");
    scanf("%d", &n);

    switch (n) {
        case 1: printf("pazartesi\n");break;
        case 2: printf("sali\n");break;
        case 3: printf("carsamba\n");break;
        case 4: printf("persembe\n");break;
        case 5: printf("cuma\n");break;
        case 6: printf("cumartesi\n");break;
        case 7: printf("pazar\n");break;
    default: printf("gecersiz\n");
    }

    printf("switch deyimi yurutuldu\n");

    return 0;
}

/****************************************************/
/****************************************************/

#include "utility.h"
#include <stdio.h>

int main()
{
    int n;
    printf("haftanin kacinci gunu : ");
    scanf("%d", &n);

    switch (n) {
        default: printf("gecersiz\n"); break;
        case 1: printf("pazartesi\n");break;
        case 2: printf("sali\n");break;
        case 3: printf("carsamba\n");break;
        case 4: printf("persembe\n");break;
        case 5: printf("cuma\n");break;
        case 6: printf("cumartesi\n");break;
        case 7: printf("pazar\n");break;

    }

    printf("switch deyimi yurutuldu\n");

    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <stdio.h>

int main()
{
    int n;
    printf("haftanin kacinci gunu : ");
    scanf("%d", &n);

    switch (n) {
        case 4: printf("persembe\n");break;
        case 1: printf("pazartesi\n");break;
        case 7: printf("pazar\n");break;
        case 3: printf("carsamba\n");break;
        default: printf("gecersiz\n"); break;
        case 5: printf("cuma\n");break;
        case 2: printf("sali\n");break;
        case 6: printf("cumartesi\n");break;

    }

    printf("switch deyimi yurutuldu\n");

    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <stdio.h>

int main()
{
    int n;
    printf("haftanin kacinci gunu : ");
    scanf("%d", &n);

    //7
    switch (n) {
        case 4: printf("persembe\n");break;
        case 1: printf("pazartesi\n");break;
        case 7: printf("pazar\n");
        case 3: printf("carsamba\n");break;
        default: printf("gecersiz\n"); break;
        case 5: printf("cuma\n");
        case 2: printf("sali\n");break;
        case 6: printf("cumartesi\n");break;

    }

    printf("switch deyimi yurutuldu\n");

    return 0;
}

/****************************************************/
/****************************************************/



#include "utility.h"
#include <stdio.h>

int main()
{
    int n;
    printf("haftanin kacinci gunu : ");
    scanf("%d", &n);


    switch (n)
    case 4: printf("persembe\n");
        break;//bu sentaks hatası switch scope da değil


    printf("switch deyimi yurutuldu\n");

    return 0;
}

/****************************************************/
/****************************************************/
#include "utility.h"
#include <stdio.h>


//militry format
//5th May 1992

void display_date(int day, int month, int year)
{
    printf("%d", day);

    switch (day) {
        case 1:
        case 21:
        case 31: printf("st "); break;
        case 2:
        case 22: printf("nd "); break;
        case 3:
        case 23: printf("rd "); break;
        default: printf("th "); break;
    }

    switch (month) {
        case 1: printf("Jan "); break;
        case 2: printf("Feb "); break;
        case 3: printf("Mar "); break;
        case 4: printf("Apr "); break;
        case 5: printf("May "); break;
        case 6: printf("Jun "); break;
        case 7: printf("Jul "); break;
        case 8: printf("Aug "); break;
        case 9: printf("Sep "); break;
        case 10: printf("Oct "); break;
        case 11: printf("Nov "); break;
        case 12: printf("Dec "); break;
    }

    printf("%d\n", year);

}

int main()
{
    int day, month, year;

    printf("gun ay yil olarak tarih girin : ");
    scanf("%d%d%d", &day, &month, &year);

    display_date(day, month, year);


    return 0;
}

/****************************************************/
/****************************************************/

#include "utility.h"
#include <stdio.h>


int main()
{
    int day, month, year;

    printf("gun ay yil olarak tarih girin : ");
    scanf("%d%d%d", &day, &month, &year);

    switch (day) {
      case 1: printf("1\n"); //fallthrough
      case 2: printf("2\n"); break;
      case 3: printf("3\n"); break;
    }

    //C++


    return 0;
}

/****************************************************/
/****************************************************/

#include "utility.h"
#include <stdio.h>

int day_of_year(int d, int m, int y)
{
    int sum = d;

    switch (m-1) {
        case 11: sum += 30; //fallthrough
        case 10: sum += 31; //fallthrough
        case 9: sum += 30; //fallthrough
        case 8: sum += 31; //fallthrough
        case 7: sum += 31; //fallthrough
        case 6: sum += 30; //fallthrough
        case 5: sum += 31; //fallthrough
        case 4: sum += 30; //fallthrough
        case 3: sum += 31; //fallthrough
        case 2: sum += (isleap(y) ? 29 : 28); //fallthrough
        case 1: sum += 31; //fallthrough
    }

    return sum;
}

int main()
{
    int day, month, year;

    printf("gun ay yil olarak tarih girin : ");
    scanf("%d%d%d", &day, &month, &year);

    printf("%d yilin %d. gunu\n", year, day_of_year(day, month, year));


    return 0;
}

/****************************************************/
/****************************************************/



goto statement

programın akısını belirli bir noktaya yönlendirme işlemidir


goto deyimi local jump görevi vardır

void func()
{
}

gercek bir ihtiyac olmadıgı sürece kullanmayın


labe lar

identifier dır

etiket:  seklinde kulanacaz

etiketten sonra bir statement gelmek zorunda

label:
   statement;


#include "utility.h"
#include <stdio.h>


int main()
{

    http://github.com
        ;


    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <stdio.h>


int a = 10;

int func(void)
{
    //statement
    //statement
    //statement

    goto OUT;

    //statement
    //statement
    //statement
    //statement
OUT:
   a = 5;

}

int main()
{

    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <stdio.h>


int a = 10;

int func(void)
{

OUT:
   a = 5;

    //statement
    //statement
    //statement

    goto OUT;

    //statement
    //statement
    //statement
    //statement

}


int main()
{

    return 0;
}

/****************************************************/
/****************************************************/

ne zamn goto kullanabiliriz

nested loops iç içe donguler




#include "utility.h"
#include <stdio.h>


int main()
{
    int flag = 0;

    for (int i = 0; i < 10; ++i) {
        int  n = 20;

        while (--n) {
            //statement

            for (int k = 0; k < 10000; ++k) {
                if(1){
                    flag = 1;
                    break;
                }
            }

            if(flag)
                break;
        }

        if(flag)
            break;
    }

    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <stdio.h>

void foo(void);

int main()
{
    for (int i = 0; i < 10; ++i) {
        int  n = 20;

        while (--n) {
            //statement

            for (int k = 0; k < 10000; ++k) {
                if(1){
                    goto out;
                }
            }
        }
    }
out:
    foo();

    //

    return 0;
}

/****************************************************/
/****************************************************/





#include "utility.h"
#include <stdio.h>

int a = 10;

int func(void)
{
    //statement
    //statement
    //statement

    int OUT;

    goto OUT;

    //statement
    //statement
    //statement
    //statement
OUT:
   a = 5;

}

int main()
{


    return 0;
}

/****************************************************/
/****************************************************/

type conversions -- tur donusumleri

bir ifadenin dogrudan kullanılması yerine onun
farklı bir turde ifade edilerek o turde kullanılması işlemidir


iki gruba ayırıyoruz

implicit type conversions // gizli tür dönüşümleri
   kodda boyle bir talep olmasına ragmen derleyici durumdan vazife çıkartıp
   tur donusumu gercekleştiriyor


explicit type conversions  //acık tur donusumu
 kullanıcı tarafından gerceklestirilen
 yani bilerek ve isteyerek
 bunun için type-cast operatoru kullanılır



implicit type conversions

iki ayrı senoryoda karşımıza çıkacak
  usual arithmetic convertion
   operatorlerin kullanılması durumunda yapılan conversionlar

   a+b
   +x
   a > b

  as if assignment
  atam donusumleri

   x = y // atama
   T a = b; //ilk deger verme
   func(i) // fonksiyon cagırma
   return ival // deger donme

  hepsinin ortak özelliği kopyalama




#include "utility.h"
#include <stdio.h>


int main()
{
    int x = -1;
    unsigned int y = 234;

    if( x > y)
        printf("DOGRU\n");
    else
        printf("YANLIS\n");

    return 0;
}

/****************************************************/
/****************************************************/




#include "utility.h"
#include <stdio.h>


int main()
{
    char c = 165;

    if( c == 165)
        printf("DOGRU\n");
    else
        printf("YANLIS\n");

    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <stdio.h>


int main()
{
    float f = 0.4f;

    if( f == 0.4)
        printf("DOGRU\n");
    else
        printf("YANLIS\n");

    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <stdio.h>

//usual aritmatic conversion

int main()
{
    int x = 10;
    double d = x / 3;

    printf("sonuc = %f\n", d);

    return 0;
}

/****************************************************/
/****************************************************/

neden donusume ihtiyac var
cunkü veri kaybını onelmek ve yanlıs işlemlerdden kacınmak için


operandlardan biri long double turunde ise
 digerinin long double turunde ise
 işlem long double türünde yacaz


operandlardan biri double turunde ise
 digerinin double turunde ise
 işlem double türünde yacaz


operandlardan biri float turunde ise
 digerinin float turunde ise
 işlem float türünde yacaz

--------------------------------



------------------------------------------->
char short int logn float double long double
rank

operandların turu ve rank aynı ise aynı turden işlem yapılır

ranklar farklı ise ve yuksek olan rank işaretsiz ve düşük olan rank işaretli
ise işlem işaretsiz yüksek rankta yapılacak.
unsigned long  signed int   ---> unsigned long


rank aynı işaretler farklı ise, herzaman türler işaretsiz olan türde yapıalcak
signed int unsigned int   --> unsigned int

ranklar farklı işaretler farklı ve buyuk olan rank işaretli kucuk olan rank işaretsiz ise
örnek
   signed long  unsigned int
     4 byte      4 byte        --> unsigned long      -32344  32343     0   65345
     4 byte      2 byte        --> signed long       -32344  32452     0   1284

eger signed long unsigned int degerlerini kapsar ise signed long ta
işlem yapıalcak
kapasamaz ise unsigned long te işlem yapıalcak


long long / unsigned long long
long / unsigned long
int / unsigned int



---------------------------------------


int türünden daha kucuk türler işleme sokukmadan önce
int türüne yukseltiliyorlar
buna integral promotion denir...


short
char / signed char unsigned char
_Bool

------------------------------------------------

#include "utility.h"
#include <iostream>

int main()
{
    char ch1 = 4;
    char ch2 = 5;

    std::cout << typeid (ch1 + ch2).name() << "\n";

    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <iostream>

int main()
{
    char ch1 = 4;
    short ch2 = 5;

    //integral type  ile int  yukselyme olur
    std::cout << typeid (ch1 + ch2).name() << "\n";

    return 0;
}

/****************************************************/
/****************************************************/



#include "utility.h"
#include <iostream>

int main()
{
    short ch1 = 4;
    short ch2 = 5;

    //integral type  ile int  yukselyme olur
    std::cout << typeid (ch1 + ch2).name() << "\n";

    return 0;
}

/****************************************************/
/****************************************************/



#include "utility.h"
#include <iostream>

int main()
{
    int ch1 = 4;
    unsigned int ch2 = 5;

    //integral type  ile int  yukselyme olur
    std::cout << typeid (ch1 + ch2).name() << "\n";

    return 0;
}

/****************************************************/
/****************************************************/

#include "utility.h"
#include <iostream>

int main()
{
    long ch1 = 4;
    unsigned long ch2 = 5;

    //integral type  ile int  yukselyme olur
    std::cout << typeid (ch1 + ch2).name() << "\n";

    return 0;
}

/****************************************************/
/****************************************************/

#include "utility.h"
#include <iostream>

int main()
{
    int ch1 = 4;
    unsigned long ch2 = 5;

    //integral type  ile int  yukselyme olur
    std::cout << typeid (ch1 + ch2).name() << "\n";

    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <iostream>

int main()
{
    unsigned int ch1 = 4;
    long ch2 = 5;

    //integral type  ile int  yukselyme olur
    std::cout << typeid (ch1 + ch2).name() << "\n";

    //std::cout << sizeof (unsigned int) << "\n";
    //std::cout << sizeof (long) << "\n";

    return 0;
}

/****************************************************/
/****************************************************/

#include "utility.h"
#include <iostream>

int main()
{
    char c = 12;

    std::cout << typeid (+c).name() << "\n";


    return 0;
}

/****************************************************/
/****************************************************/



#include "utility.h"
#include <iostream>

int main()
{

    //kousl operatoru her iki operandın turene bakıp karaverioyr
    //aynı ise turleri aynı türden uretıyor
    //farklı ise hangisinin ranki ve işaretli işsaretsiz olmasına göre  degerlendiriyor
    std::cout << typeid (10 > 5 ? 3 : .5).name() << "\n";


    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <iostream>

int main()
{
    int x = 12;
    int y = 5;

    double dval = x / y;

    std::cout << typeid (x / y).name() << "\n";
    std::cout << typeid (dval).name() << "\n";


    return 0;
}

/****************************************************/
/****************************************************/



#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{
    int x = -1;
    unsigned int y = 1;

    //unsigned int

    // -1  butun bitler  1111 1111 1111  1111 1111
    //4 byte alabilecegi en buyuk tam sayıya donusur


    if(x > y)
        printf("DOGRU\n");
    else
        printf("YANLIS\n");

    return 0;
}

/****************************************************/
/****************************************************/


dikkat

işsaretli türlerde taşma tanımsız davranış

işsaretsiz türlerde taşma - modüler aritmatic devreye girer
x ve y unsigned int türünden olsun

x * y // eger sonuc alabilecek degerin üsütndey ise


carpma sonucu degeri unsigned int  türünün en buyuk deger + 1

peki bu ne demek

en büyük degere  + 1 toplar iseniz bu size 0 degerini verir







#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{
    unsigned x = UINT_MAX;

    printf("x  = %u\n", x);
    ++x;
    printf("x  = %u\n", x);

    return 0;
}

/****************************************************/
/****************************************************/

#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{
    unsigned x = UINT_MAX;

    printf("x  = %u\n", x);
    x += 20;
    printf("x  = %u\n", x);

    return 0;
}

/****************************************************/
/****************************************************/


atama tür dönüşümleri

1- bir değişkene ilk degerme
2- atama yapıldıgında
3- bir fonksiyona argüman olarak gönderildiğinde
4- fonksiyonun return deyimiydi


atama hangi türe ise donusum o yöne yapıalcak


int = double // int türne donuusm olacak
burda veri kaybı yasarsınız


float = short // float
veri kaybı olmaz





#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{

    unsigned int x = -1;

    //1111 1111 1111 1111 1111 ...

    printf("x = %u\n", x);
    printf("x = %u\n", UINT_MAX);

    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{

    unsigned long long x = -1;

    //-1 --  signed int
    //1111 1111 1111 1111 1111 1111 1111 11111

    //burada sign extention yapılır 1111 ile doldurulur unsigned oldugu için
    // 1111 1111 1111 1111 1111 1111 1111 11111 1111 1111 1111 1111 1111 1111 1111 11111


    printf("x = %llu\n", x);

    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{

    double dval = 67542;

    printf("dval = %f\n", dval);

    return 0;
}

/****************************************************/
/****************************************************/

#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{
    //ufak kayıplar yasanır dikkatli olun
    //boyle buyuk sayılarda
    float dval = 2000000001;

    printf("dval = %f\n", dval);

    return 0;
}

/****************************************************/
/****************************************************/

truncation  --- budama


2a bc 14 fa

eger bu deger i 2 bute lik sisteme atar isek

yuksek anlamlı bitleri

14 fa degerlerini alır


#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{
    unsigned short x = 0x1ac4d2e5;

    printf("x = %x\n", x);
    printf("x = %d\n", x);

    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{
    //short 2 byte
    short s = 1000000;  // F 42 40

    printf("s = %d\n", s); // 16 960
    printf("s = %x\n", s);

    return 0;
}

/****************************************************/
/****************************************************/



#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{
    //ufak kayıplar yasanır dikkatli olun
    //boyle buyuk sayılarda

    float dval = 20000001;

    printf("dval = %f\n", dval);

    return 0;
}

/****************************************************/
/****************************************************/

truncation -- budama

2a bc 14 fa


eger bu degeri 2 byte lık sisteme atar isek

yuksek anlamlı bitleri atar keser

14 fa degerleri elimiz de kalır


#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{
    unsigned short x = 0x1ac4d2e5;

    printf("x = %x\n", x);

    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{
    short x = 1000000; // F 4240
                        //4240
    printf("x = %d\n", x); //16960

    return 0;
}

/****************************************************/
/****************************************************/

#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{
    short x = 1000000; // F 4240
                        //4240
    char c = 1000000; //40   char 1 byte


    printf("x = %d\n", x); //16960
    printf("c = %d\n", c); //64


    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{
    short x = 0x16245080;

    char c =  0x80;

    // 0x80
    // 1010 0000  --> -128

    //signed ise ve geri kalan bitlerini  1111 1111 1111
    //unsigned ise geri kalan bitleri   0000 0000 0000 0000

    //char // unsigned signed
            //bende signed diyor
    //1010 0000 --> -128


    printf("x = %x\n", x);
    printf("c = %x\n", c);
    printf("x = %d\n", x);
    printf("c = %d\n", c);


    return 0;
}

/****************************************************/
/****************************************************/

#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{
    //negatif anlamlı birler 1111 lerle doldurulur
    //pozitif anlamlı bitler 0000 lar ile doldurulur

    //char türü derleyiciye göre işaretli veya işaretsiz olabilir
    //bizdeki işaretli ve bit düzeni değişmeyecek
    //1011 0000 c ye atanan -80 degeri atanı


    //int türüne yukseltirim   1111 1111 1111 1111 1111 1111 1111 1011 0000
    //unsigned int türünden    0000 0000 0000 0000 0000 0000 0000 1011 0000

    char c = 176; //0xB0  1011 0000

    printf("c = %x\n", c);
    printf("c = %d\n", c);

    if(c ==  176)
        printf("dogru\n");
    else
        printf("yanlis\n");

    return 0;
}

/****************************************************/
/****************************************************/


gercek sayı türünden tam sayı türne atama yapıldıgında

ondalık kısmı dogrudan atar
ilgili kısım ifade edilebiliyor ise gecerli olur
eger edilemiyor ise tanımsız davranış olur ..



#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{
    double dval = 7234.2344234;

    int ival;

    ival = dval;

    printf("ival = %d\n", ival);


    return 0;
}

/****************************************************/
/****************************************************/


#include "utility.h"
#include <stdio.h>
#include <limits.h>

int main()
{
    double dval = 9882334512.2344234;

    int ival;

    ival = dval;

    printf("ival = %d\n", ival);


    return 0;
}

/****************************************************/
/****************************************************/

tür dönüşüm operatoru

type cast operatoru --->  ()

unary bir operator

içine tür bilgisi yazılır (data type)

2. öncelik seviyesindedir


int x;

(target type)operand;

(double)x; seklinde kullanılır




#include "utility.h"
#include <stdio.h>


int main()
{
    int x = 10;
    int y = 3;

    //double dval = x / y;
    double dval = (double)x / y;

    printf("dval = %f\n", dval);


    return 0;
}

/****************************************************/
/****************************************************/


const cast (const luk donusumu)
adreslerle ilgili donusum (pointer)

konuları gelince ileriki derte anlatacaz


farklı bir casting olayına deyinelim



#include "utility.h"
#include <stdio.h>

int foo(int a)
{
    return 1;
}

int main()
{
    //ihtiyaç oldugun da kullanabiliriz
    //bilinçli olarak geri dönüş türünü kullanmıyacagım
    (void)foo(12);

    //hayır boylede bir sıkıntı olmaz
    foo(13);


    return 0;
}

/****************************************************/
/****************************************************/

#include "utility.h"
#include <stdio.h>

int foo(int a)
{
    return 1;
}

int main()
{
    int x = 10, y = 23;

    //bilinçli olarak printfin geri donus degerinin kullanmıyacam
    (void)printf("%d%d\n", x, y);


    return 0;
}

/****************************************************/
/****************************************************/

#include <stdio.h>

// 3.4   --> 3
// 3.7   --> 4
// -2.8  --> -3
// -2.2  --> -2

int main()
{
    double dval;

    printf("[-5 +5] aralgiinda bir gercek sayi giriniz : ");
    scanf("%lf\n", &dval);

    printf("%d\n", (int)(dval + (dval > 0. ? .5 : -.5)));


    return 0;
}

/****************************************************/
/****************************************************/

Rastgele sayi üretimi

random number generation

Rastgele sayi üretimi oyun programlama - genetik algoritma
- kriptoloji --  test işlemleri -- simulasyon programları
gibi cogu yerde cokca kullanılmakta


iki Rastgele sayi uretimi mevcut
1- true randım number generation
   Dogadan faydalanarak üretılen rastgele sayılar

2- pseudo random number generation
  sozde - aslında gercek sayı uretımı yok sadece varsaymak

bilgisayarın rastgele sayı uretme ozellıgı yok
cunku bilgisayar deterministik bir yapıya sahip

bir algoritma ile rastgele sayı uretımı hissiyatı verilen bir yapı kurulur
ama aslında rastgelelık yoktur bir algoritma oldugu için


seed value (tohum degeri)
tohum degerine göre rastgele sayı uretımı bize farklı sayı zinciri sunacaktır.


kullanılan bu algoritmalar içinde random generation için
mersene twister algoritması kullanılmakta


bu algoritmalar aslında yaptıgı sey
1010101010101010101010 rasgele bitleri saglamak


uniform distribution
1-10 --> 1 2 3 10
uretilecek bu sayıların gelme ve ya olusma olasilipği aynı olmasını saglamtadır.

farklı yontemler de mevcut
Gauss distribution -->


C ve C++ random generation da aralarında buyuk farklılıklar mevcut
C sadece 2 tane fonksiyon ile destek veriririken
C++ ise bunun için bir kütüphanesi mevcut ve çokca fazla destek vermektedir

C de cok fazla ıhtıyac var ise
Thirt Party uyglma veya kutuphane kullanabiliriz



<stdlib.h> kutupohanesinde
rand ile srand fonksiyonları

bir de Makro

RAND_MAX --> maksimum üretilebilecek en buyuk tam sayı degerını temsıl eder
RAND_MAX derleyiciye baglı olarak degisebilir

#include <stdio.h>
#include <stdlib.h>

//rand işlevi default olarak seed value degeri 1 i kullanır
int main()
{
    for (int i = 0; i < 10; ++i) {
        printf("%d \n", rand());
    }

    return 0;
}

/****************************************************/
/****************************************************/


#include <stdio.h>
#include <stdlib.h>

//rand işlevi default olarak seed value degeri 1 i kullanır
int main()
{

    srand(10u); //tohum degeri

//yeni tohum degeri fakat sabit oldugu için yine aynı sayıları uretecek
    for (int i = 0; i < 10; ++i) {
        printf("%d \n", rand());
    }

    return 0;
}

/****************************************************/
/****************************************************/

#include <stdio.h>
#include <stdlib.h>


void print_random_numbers(unsigned int seed)
{
    srand(seed);

    for (int i = 0; i < 10; ++i) {
        printf("%d \n", rand());
    }
}

int main()
{

    for (int i = 1; i < 1000; ++i) {
        printf("seed value is %5d\n", i);
        print_random_numbers(i);
        getchar();
        system("cls");
    }


    return 0;
}

/****************************************************/
/****************************************************/


int rand(void) yapıya sahip
void srand(unsigne int) yapiya sahip;

#include <stdio.h>
#include <stdlib.h>


int main()
{

//uniform dağılım için mod operatoru kkullanmayınız

    for (int i = 1; i < 1000; ++i) {
        printf("%d ", rand() % 6 + 1);
    }


    return 0;
}

/****************************************************/
/****************************************************/

#include <stdio.h>
#include <stdlib.h>

#define     RANDOM_MIN_YEAR     1960
#define     RANDOM_MAX_YEAR     2010

int main()
{
    for (int i = 1; i < 100; ++i) {
        printf("%d ", rand() % (RANDOM_MAX_YEAR - RANDOM_MIN_YEAR + 1) + RANDOM_MIN_YEAR);
    }

    return 0;
}

/****************************************************/
/****************************************************/

cleander time dediğimiz bir mekanizma var

01.01.1970 12:33

bunun arkda tarafta şu şekilde

456456234234 gibi bir degere takabul ediyor

bunun için time kutuphanesi gerekli


#include <stdio.h>
#include <stdlib.h>
#include <time.h>


int main()
{
    printf("%lld\n", time(NULL));


    return 0;
}

/****************************************************/
/****************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>


int main()
{
    for (;;) {
        printf("%lld\r", time(NULL));
    }


    return 0;
}

/****************************************************/
/****************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <time.h>


int main()
{
    srand((unsigned)time(NULL));

    return 0;
}

/****************************************************/
/****************************************************/


#include <stdio.h>
#include "utility.h"

int main()
{
    randomize();

    for (int i = 0; i < 5; ++i) {
        printf("%d\n", rand());
    }

    return 0;
}

/****************************************************/
/****************************************************/

#include <stdio.h>
#include "utility.h"

int main()
{
    randomize();

    for (int i = 0; i < 5; ++i) {
        printf("%d\n", rand());
    }

    return 0;
}

/****************************************************/
/****************************************************/


#include <stdio.h>
#include "utility.h"

int main()
{
    randomize();

    for (;;) {
        putchar(rand() % 26 + 'A');
        xSleep(0.05);
    }

    return 0;
}

/****************************************************/
/****************************************************/

#include <stdio.h>
#include <ctype.h>
#include "utility.h"

int main()
{
    randomize();

    for (;;) {
        int val = rand() % 128;
        if(isupper(val)){
            putchar(val);
            xSleep(0.05);
        };
    }

    return 0;
}

/****************************************************/
/****************************************************/

#include <stdio.h>
#include <ctype.h>
#include "utility.h"

int main()
{
    randomize();

    for (;;) {
        int val = rand() % 128;
        if(ispunct(val)){
            putchar(val);
            xSleep(0.05);
        };
    }

    return 0;
}

/****************************************************/
/****************************************************/


#include <stdio.h>
#include <ctype.h>
#include "utility.h"

int get_random_char(void)
{
    int c;

    while (1) {
        c = rand() % 128;
        if(isalpha(c)){
            return c;
        }
    }
}

void print_random_password(void)
{
    int len;

    len = rand() % 10 + 4;
    for (int i = 0; i < len; ++i) {
        putchar(get_random_char());
    }

    putchar('\n');
}

int main()
{
    randomize();

    for (int i = 0; i < 10; ++i) {
        print_random_password();
    }

    return 0;
}

/****************************************************/
/****************************************************/

#include <stdio.h>
#include <ctype.h>
#include "utility.h"

int get_random_char(void)
{
    int c;

    while (1) {
        c = rand() % 128;
        if(isalpha(c)){
            return c;
        }
    }
}

void print_random_password(void)
{
    int len;

    //randomize();
    len = rand() % 10 + 4;
    for (int i = 0; i < len; ++i) {
        putchar(get_random_char());
    }

    putchar('\n');
}

int main()
{
    randomize();
    for (int i = 0; i < 10; ++i) {
        print_random_password();
    }

    return 0;
}

/****************************************************/
/****************************************************/

#include <stdio.h>
#include <ctype.h>
#include "utility.h"

#define     NTOSS       100000
#define     HEADS       1   //tura


int main()
{
    randomize();

    int heads_count = 0;

    for (int i = 0; i < NTOSS; ++i) {
        if(rand() % 2 == HEADS)
            ++heads_count;
    }

    printf("olasilik = %f\n", (double) heads_count / NTOSS);

    return 0;
}

/****************************************************/
/****************************************************/

#include <stdio.h>
#include <ctype.h>
#include "utility.h"


/*
 * oyun kuralları
 *
 * zarların taoplamı en dusuk 2 en buyuk 12
 *
 * atılan zarların toplamına göre oyuncy ya para kaybetcek ya para kazancak
 *
 * eger zarların 1. atılışında
 * toplam
 *
 * 7 - 11 ise ---> oyuncu kazanır
 * 2 - 3 - 12 ise --> oyuncu kayber kasa kazanır
 * 4 - 5 - 8 - 9 - 10 ise --> oyunun kuralları değişir
 *
 * eger oyunun kuralları değişirse
 * örnek
 * 9 attık ve tekrar 9 atar isek kazandık
 * 5
 * 11
 * 3
 * 8
 * 6
 * 9 eger burada 9 yerine 7 atsaydım kasa kazandı ben kaybettim
 *
 *
 * soru su oyuncunun oyunu kazanma olasılıhı nedir
 * %49,3455   -->  kasıının ki -->%50.23434
 *
 *
 *
 *
 */

#define     NGAMES      1000000

int roll_dice(void)
{
    int dice_1 = rand() % 6 + 1;
    int dice_2 = rand() % 6 + 1;

    return dice_1 + dice_2;
}

int gameRule(int dice)
{
    while (1) {
        int new_dice = roll_dice();
        if(new_dice == dice)
            return 1;
        if(new_dice == 7)
            return 0;
    }
}

int game(void)
{
    int dice = roll_dice();

    switch (dice) {
    case 7:
    case 11: return 1;
    case 2:
    case 3:
    case 12: return 0;
    default: return gameRule(dice); break;
    }

}

int main()
{
    randomize();

    int win_count = 0;

    for (int i = 0; i < NGAMES; ++i) {
        win_count += game();
    }

    printf("kazanma olasiligi = %f\n", 100. * win_count / NGAMES);

    return 0;
}

/****************************************************/
/****************************************************/

C+++ random fnksiyonlarını yazalım


#include <stdio.h>
#include <ctype.h>
#include "utility.h"
#include <random>


/*
 * oyun kuralları
 *
 * zarların taoplamı en dusuk 2 en buyuk 12
 *
 * atılan zarların toplamına göre oyuncy ya para kaybetcek ya para kazancak
 *
 * eger zarların 1. atılışında
 * toplam
 *
 * 7 - 11 ise ---> oyuncu kazanır
 * 2 - 3 - 12 ise --> oyuncu kayber kasa kazanır
 * 4 - 5 - 8 - 9 - 10 ise --> oyunun kuralları değişir
 *
 * eger oyunun kuralları değişirse
 * örnek
 * 9 attık ve tekrar 9 atar isek kazandık
 * 5
 * 11
 * 3
 * 8
 * 6
 * 9 eger burada 9 yerine 7 atsaydım kasa kazandı ben kaybettim
 *
 *
 * soru su oyuncunun oyunu kazanma olasılıhı nedir
 * %49,3455   -->  kasıının ki -->%50.23434
 *
 *
 *
 *
 */

#define     NGAMES      1000000

int roll_dice(void)
{
    static std::mt19937 eng;
    static std::uniform_int_distribution<int> dist{1, 6};

    int dice_1 = dist(eng);
    int dice_2 = dist(eng);

    return dice_1 + dice_2;
}

int gameRule(int dice)
{
    while (1) {
        int new_dice = roll_dice();
        if(new_dice == dice)
            return 1;
        if(new_dice == 7)
            return 0;
    }
}

int game(void)
{
    int dice = roll_dice();

    switch (dice) {
    case 7:
    case 11: return 1;
    case 2:
    case 3:
    case 12: return 0;
    default: return gameRule(dice); break;
    }

}

int main()
{
    //randomize();

    int win_count = 0;

    for (int i = 0; i < NGAMES; ++i) {
        win_count += game();
    }

    printf("kazanma olasiligi = %f\n", 100. * win_count / NGAMES);

    return 0;
}

/****************************************************/
/****************************************************/

Ödev Sorusu

1- monte-carlo yöntemi ile pi sayısını hesapmanız isteniyor


2- Kumar oyunun sümilasyonu

oyuncunun 100 doları va ve kasaya karsı oynuyor kasanında 100 doları var

oyuna girebilmek için 10 doları verilir ve  yazı tura atıyor

kural şu

arka arkaya YAZI YAZI gelir ise 35 Dolar verir kasa size
Arka arkaya TURA TURA TURA gelir ise 60 dolar verir kasa size

soru şu oyuncunun bu oyunu kazanma olasılıgı nedir


kasanın kaybetmesi için 60 altına düştümü yani ödeme tutarının altına düşmesiyle kaybeder
ornek odemsi olacak kasanın 59 elinde kaldı o zamn kaybetti

oyuncuda 10 doların altına duser ise tekrar oyuna göremez ise kaybeder

2 Yazı gelince sayac sıfırlanır
3 T gelince sayac sıfırlanır

/*****************************************************/
/*****************************************************/

veri yapıları
algoritma

Array konusuna giriş



veri yapıları ve algoritmalar

veri yapsının  --> data structure
buna en yakın ADT(abstract data type) bahsedecez

Verilerin bellekte ne şekilde tutulduguna ilişkin organizasyon
Neden bu gerekli bu tutgumuz verilerin ne sekılde tutuyorsanız bu verielere
ulasmanız farklılık gosterebilir ve onemlidir



çok sayıda veri yapısı var işimize hangisi yarıyor ise onu seçmemiz lazım
veri yapısı C ye ozgu değil bir çok dile özgü genel bir konu

En çok hangi veri yapsıı kullanılıyor diyorsanız ---> dynamic array


sırası ile gelmesi verielerin avantajı
Fixed arrayın avantajı

index bilgisi ile veri elemnalrından birisine
constant time (sabit zamanda) ulasabiliriz

eger sık sık verielerde yuksek maliyet olmadan erişmek istiyor isek
en iyi veri yapsıı dinamik dizi


ayrıca dinamik dizilere veri ekleme maliyeti az
yani sondan ekleme işlemi constant time  da



Algoritma
programlama ile ilgili değil
amacı bir işi nasıl yapmalıyım hangi aşamalardan geçirmeliyim


algoritma elimizde bir veri yapısı olması lazım ki devre ye girebilsin

bir işi ne kadar surede ne kadar az işlemle yapılması için
kullanılan paremetreleeri iyi seçmeleyiz
ve kurdugumuz algoritmada en hızlısı ve en az işlemlisini seçmeliyiz
kullandıgı bellekte onemlidir.

algoritma karmaşıklıgı ---> complexcity karmaşıklıgı

iki faktor önemli
1- kaç tane işlemde devreye giriyor
2- kullanılan bellek açısından ele alınır


Big O notasyonu

Veri yapsıınıdaki öge sayısının artışıyla yapılan işlem sayısı arasındaki ilişki

O() --> parantez içine yazdıgımız ifadeler algortimanın karmasıklıgını gösteriyor

O(1)  constant time -->  veri yapısındaki öge sayısı ne kadar artarsa artsın maliyet
                        değişmiyor

O(n) liner complexcity  --> veri yapısındaki öge ne kadar artarsa maliyeti o kdar artıyor

O(n*log n)

O(n^2)  --> veri yapsıındaki oge sayısının karesı ile dogru orantılı olarak artıyot işlem maliyeti


O(n2 * log n)

O(n^3)
O(n!)

---------------------------------------------------------------------

C Array

teknik ismi --> Fix Array

-->Dynamic Array


--------------------------
teknik ismi --> Fix Array

bellekte ardışık olarak yerleştirilen  ve sonradan ekleme ve çıkartma olamayn data struct Fixed array
compile time da C derleyicisi bunu sabit ifadesi olarak alır

ardık olması ile index bilgisi ile constant time da ulaşılır


C de dizi tanımlama sentakslarından bahsedelim



#include <stdio.h>

int main()
{
    //boyutunu constan exprestion yazmanız lazım
    //tam saıy turu olması lazım yoksa sentaks hatası olur
    //boyutu sıfır olamaz sentaks hatası
    //negatif de olmaz senyaks hatası
    int arr[10];

    return 0;
}


/****************************************************/
/****************************************************/

#include <stdio.h>

#define     ARRAYSIZE       100

int main()
{

    int arr[ARRAYSIZE];

    return 0;
}


/****************************************************/
/****************************************************/

#include <stdio.h>

#define     ARRAYSIZE       100

int main()
{

    //böylebir yazım yapaibliriz ama yapmayalım görüntü kotu
    int x, arr[ARRAYSIZE] , b[10], t;

    return 0;
}


/****************************************************/
/****************************************************/

#include <stdio.h>

#define     ARRAYSIZE       100

//globak dizi
//ilk deger vermezsek hayata elemanları 0 degeri ile gelir
int a[10];

void func()
{
    //otomatik ömürlü elemanlarına deger vermez isek
    //çöp degeri ile hayata gelirler
    int b[20];

    //static omurlu dizi elemanlarına deger vermezsek 0 ile hayat gelir
    static int c[30];

}


int main()
{



    return 0;
}


/****************************************************/
/****************************************************/

C dilinde bir gonksiyonun parametre değişkeni dizi olamaz

#include <stdio.h>

//dizi niyeti ile yapmayın dizi değil çünkü
void func(int a[])
{


}


int main()
{

    return 0;
}


/****************************************************/
/****************************************************/

C dilinde bir fonsksiyonun geri donus türü dizi olamaz

bu işlemleri pointerlarda görecez



----------------------

assignable  --> atanabilir varlıklar anlamına gelir

int a[]
int b[]

a = b;  seklın bir kurduk


bir çok dilde diziyi boyle atayabiliriz
fakat C de böyle bir atma yok yapamayız

C de atama operatorunun sol operandı bir dizi olamz

-----------------------------------------

int a[];

a  --> &a[0]  bu ikiside aynı yeri işaret eder

dizinin ilk elemanın adresidir



#include <stdio.h>


int main()
{
    //bende int türünden 10 tane var demek
    int a[10];

    return 0;
}


/****************************************************/
/****************************************************/


bir dizinin elemanlarına erişmek için pointer kullanılır
şuan için ezbere kullanmıl olacaz ana detaylı oalrak pointer konusunda görecez

[] -> & *  bunlar pointer operatorudur


-----------------------------------------


dizinin ilk elemanına erişmek için 0 index'ine erişmek gerekli

dizi 10 eleman lı olsun

a[0]  --> birinci eleman
a[9]  --> son eleman



eger index biglisinnii buyuk veya kucuk verdim aşarsak sentaks hatası
tanımsız davranışa duser

bundan programcı sorumludur

#include <stdio.h>


int main()
{
    int a[100];

    //operator işlemlerinni yapabiliriz
    a[6];

    int x;

    a[7] = x;

    return 0;
}


/****************************************************/
/****************************************************/

traverse -- traversal  --> dizi yi dolaşmak anlamında kullanılır

iterate

bu terimler kullanılır diziyi dolaşmak için



#include <stdio.h>


int main()
{
    int a[100];

    for (int i = 0; i < 100; ++i) {
        a[i] = 1;
        ++a[i];
        a[i] += 1;
    }

    return 0;
}


/****************************************************/
/****************************************************/

#include <stdio.h>

#define     SIZE        10

int main()
{
    int a[SIZE];

    for (int i = 0; i < SIZE; ++i) {
        printf("%d ", a[i]);
    }

    return 0;
}


/****************************************************/
/****************************************************/


#include <stdio.h>

#define     SIZE        10

int a[SIZE];

int main()
{

    for (int i = 0; i < SIZE; ++i) {
        printf("%d ", a[i]);
    }

    putchar('\n');

    return 0;
}


/****************************************************/
/****************************************************/


#include <stdio.h>

#define     SIZE        10



int main()
{
    static int a[SIZE];

    for (int i = 0; i < SIZE; ++i) {
        printf("%d ", a[i]);
    }

    putchar('\n');

    return 0;
}


/****************************************************/
/****************************************************/

#include <stdio.h>

#define     SIZE        10

int main()
{
    int a[SIZE];

    int i;
    while (i < SIZE) {
        printf("%d ", a[i++]);
        //i++;
    }

    putchar('\n');

    return 0;
}


/****************************************************/
/****************************************************/


diziye ilk deger verme


#include <stdio.h>

#define     SIZE        5

int main()
{
    int a[SIZE] = {1, 3, 4 ,6, 7};

    for (int i = 0; i < SIZE; ++i) {
        printf("%d ", a[i]);
    }

    putchar('\n');

    return 0;
}


/****************************************************/
/****************************************************/


#include <stdio.h>

#define     SIZE        5

int main()
{
    //boyutunda fazla eleman vermek sentaks hatasına neden olur
    int a[SIZE] = {1, 3, 4 ,6, 7, 45, 23};

    for (int i = 0; i < SIZE; ++i) {
        printf("%d ", a[i]);
    }

    putchar('\n');

    return 0;
}


/****************************************************/
/****************************************************/
#include <stdio.h>

#define     SIZE        10

int main()
{
    //boyutun az eleman verir isek kalan ogeleri 0 ile dolduruyor
    int a[SIZE] = {1, 3, 4 ,6, 7, 45, 23};

    for (int i = 0; i < SIZE; ++i) {
        printf("%d ", a[i]);
    }

    putchar('\n');

    return 0;
}


/****************************************************/
/****************************************************/


#include <stdio.h>

#define     SIZE        10

int main()
{

    int a[SIZE] = {1};

    for (int i = 0; i < SIZE; ++i) {
        printf("%d ", a[i]);
    }

    putchar('\n');

    return 0;
}


/****************************************************/
/****************************************************/


#include <stdio.h>

#define     SIZE        10

int main()
{

    //sentaks hatası olur
    int a[SIZE] = {};

    for (int i = 0; i < SIZE; ++i) {
        printf("%d ", a[i]);
    }

    putchar('\n');

    return 0;
}


/****************************************************/
/****************************************************/

#include <stdio.h>

#define     SIZE        10

int main()
{

    int a[SIZE] = {0};

    for (int i = 0; i < SIZE; ++i) {
        printf("%d ", a[i]);
    }

    putchar('\n');

    return 0;
}


/****************************************************/
/****************************************************/
#include <stdio.h>

#define     SIZE        5

int main()
{

    //dizinin son elemanından sonra , kona bilir
    //bu virgule trailing comma denir
    int a[SIZE] = {1, 2, 3, 4, 5,};

    for (int i = 0; i < SIZE; ++i) {
        printf("%d ", a[i]);
    }

    putchar('\n');

    return 0;
}


/****************************************************/
/****************************************************/


#include <stdio.h>

#define     SIZE        5

int main()
{

    //sentka shatası dizinin bu durumda boyutunu yazmak zorundayım
    int a[];


    return 0;
}


/****************************************************/
/****************************************************/
#include <stdio.h>

#define     SIZE        5

int main()
{

    //EGER ildk deger verirlıyor ve dizinin boyutu verilmiyor ise
    //compile time da derleyici sizin yerine sayar ve dizinin boyutunu veririr
    int a[] = {1, 2, 3, 4};


    return 0;
}


/****************************************************/
/****************************************************/

#include <stdio.h>

#define     SIZE        100

int main()
{
    //C99
    //designated initializer

    int a[SIZE] = {[22] = 65, [12] = 39, [55] = 441};

    for (int i = 0; i < SIZE; ++i) {
        printf("a[%d] = %d\n", i, a[i]);
    }


    return 0;
}


/****************************************************/
/****************************************************/
#include <stdio.h>

#define     SIZE        100

int main()
{
    //C99
    //designated initializer

    int a[] = {[22] = 65, [12] = 39, [49] = 441};

    for (int i = 0; i < 50; ++i) {
        printf("a[%d] = %d\n", i, a[i]);
    }


    return 0;
}


/****************************************************/
/****************************************************/


C99 ile variable length array (VLA) dizi farklıdır Fixed arrayden
VLA derleyiciye baglı olarak desteklenir

VLA ilerleyen derlerde bahsedecez onemli oldugu için

/****************************************************/


temel algoritmları C de kolayacagız




#include <stdio.h>
#include "utility.h"

#define     SIZE        100

int main()
{
    int a[SIZE];

    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);


    return 0;
}


/****************************************************/
/****************************************************/
























































































































































































































































